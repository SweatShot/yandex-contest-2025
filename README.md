# yandex-contest-2025

# A. Отображение таблицы в консоль

Напишите функцию `makeTable`, которая формирует строку для отображения таблицы в виде текста.  

**Требования к таблице:**
- Размеры таблицы определяются содержимым.
- Вертикальные границы: `|`
- Углы: `#`
- Горизонтальная граница: `=`
- Для `null` или `undefined` выводить `-`
- Если список колонок пуст — возвращать пустую строку.

---

## Входные данные

1. Первый аргумент: список объектов — данные для отображения.
2. Второй аргумент: массив ключей — порядок колонок.  

Даже если все значения колонки `undefined` или `null`, колонка отображается.

---

## Выходные данные

Строка таблицы вида:

#==========#=====================#
|headerName|anotherHeader        |
#==========#=====================#
|value     |-                    |
#==========#=====================#
|-         |-                    |
#==========#=====================#
|-         |Very impressive value|
#==========#=====================#

---


- Таблица начинается сразу с `#` и заканчивается `#`.

---

## Пример использования

```javascript
console.log(
    makeTable(
        [
            { headerName: "value" },
            { anotherHeader: null },
            { headerName: undefined, anotherHeader: "Very impressive value" },
        ],
        ["headerName", "anotherHeader"]
    )
);

/*
#==========#=====================#
|headerName|anotherHeader        |
#==========#=====================#
|value     |-                    |
#==========#=====================#
|-         |-                    |
#==========#=====================#
|-         |Very impressive value|
#==========#=====================#
*/

```

---

```javascript

## Шаблон решения

function makeTable(data, columns) {
    // Ваш код
}

module.exports = makeTable;

```

# B. Активность офиса

В Яндексе — самом технологичном и креативном офисе страны — каждый день кипит жизнь. Команды запускают новые сервисы, аналитики шутят про бигдату, менеджеры спешат на встречи, а иногда в кабинетах звучит музыка или разгорается корпоратив!  

Ваша задача — стать «невидимой Метрикой» для офиса: по заданной схеме этажей (матрица, где каждая ячейка — отдельное помещение) и истории событий вычислить, где сейчас самая яркая активность.  

---

## Описание

- Дана матрица `N x M`, представляющая офис.  
- Каждая ячейка матрицы — отдельное помещение.  
- Значение в ячейке показывает текущую активность:

| Значение | Описание                            |
|----------|-------------------------------------|
| 0        | свет выключен, людей не видно        |
| 1        | свет горит, людей не видно          |
| 2        | свет выключен, человек в помещении  |
| 3        | свет включен, человек в помещении   |
| 4        | шутят шутки                          |
| 5        | включили музыку                      |
| 6        | устроили корпоратив                  |

- Помещения индексируются так:
  - Строки снизу вверх (1 — самая нижняя строка)
  - Столбцы слева направо (1 — первый слева)  
  Например, `"3.2"` — третья снизу строка, второй столбец слева.

- История изменений (`history`) — список изменений:  
  - Каждый элемент: номер помещения + изменение состояния (целое число)  
  - Активности суммируются, например `[["2.1", 4], ["2.1", 1]]` → `"2.1"` будет иметь активность 5.

- Необходимо вернуть:
  - Номер помещения с максимальной активностью.
  - Если активности нет — `null`.
  - Если несколько помещений имеют одинаковую максимальную активность — выбрать с наименьшим номером строки, затем столбца.

---

## Входные данные

- `office`: матрица `N x M` целых чисел (от 0 до 6)
- `history`: список изменений `W`, где каждый элемент `[номер_помещения, изменение]`

**Ограничения:**  
- `3 ≤ N, M ≤ 20`  
- `0 ≤ W ≤ 50`

---

## Пример

```javascript
const office = [
  [0, 0, 0],
  [0, 0, 1],
  [2, 3, 0]
];

const history = [["3.1", 4], ["2.2", 5], ["3.2", 6]];

solution(office, history); // "3.2"

```

---

```rust
Изначально:
 ___________                         _________________
| 0 | 0 | 0 |                       | 3.1 | 3.2 | 3.3 |
| 0 | 0 | 1 |           ->          | 2.1 | 2.2 | 2.3 |   
| 2 | 3 | 0 |                       | 1.1 | 1.2 | 1.3 |

После истории:
"3.1" += 4 -> 4
"2.2" += 5 -> 5
"3.2" += 6 -> 6

```
---

```javascript

function solution(office, history) {
  // Ваш код здесь
}

module.exports = solution;

```

# С. Распространение мема в социальной сети

В социальной сети пользователи могут быть друзьями друг с другом. Если один пользователь публикует мем, то все его друзья увидят его через некоторое время.  

**Особенности:**
- Дружба всегда взаимная: если A дружит с B, то B автоматически дружит с A.  
- Некоторые пользователи первыми получили новый мем — они будут стартовыми точками распространения.  
- Мем распространяется с задержкой, указанной для каждой дружбы.  

Ваша задача — найти минимальное время, за которое мем дойдёт до целевого пользователя.  
Если мем не доходит — вернуть `-1`.

---

## Входные данные

1. `subscriptions` — список дружеских связей:  

```javascript
[ [пользователь1, пользователь2, время_передачи], ... ]
```
- **Время передачи** всегда положительное.

- **Дружба** двусторонняя.

- **starters** — список пользователей, которые первыми опубликовали мем.

- **target** — пользователь, до которого нужно определить время.

---

## Выходные данные

Минимальное время, за которое мем дойдёт до целевого пользователя, или `-1`, если это невозможно.

---

## Пример

```javascript
const subscriptions = [ [1, 2, 2], [2, 3, 3], [3, 4, 1], [4, 3, 1], [1, 4, 8] ];
const starters = [1, 4];
const target = 3;
```

---

## Объяснение:

Мем из пользователя 4 доходит до 3 за 1 (по связи 4 ↔︎ 3).

Мем из пользователя 1 идёт дольше: 1 → 2 → 3 (время = 2 + 3 = 5).

Минимальное время = 1.

---

## Шаблон решения

```javascript

module.exports = function memeSpreadTime(subscriptions, starters, target) {
    // Ваш код здесь
}

```

# D. Модель событий
---
## ОПИСАНИЕ

На вход приходит модель событий некоторой страницы, элементы которой представляют собой кастомные сущности (элементы), описывающие текущую страницу — они выдуманы. К примеру, предположим, что мы разрабатываем конструктор сайта, где пользователи не знают ничего про HTML, но могут описать страницу набором ограниченных ключей. Каждый конечный ключ возвращает функцию, ассоциированную с данной сущностью (событие).

## Пример модели:

```js
const MODEL = {
    page: {
        content: {
            form: {
                submit: someFunc1,
            },
            infoBlock: {
                more: {
                    click: someFunc2,
                },
            },
        },
        footer: {
            blog: {
                about: {
                    expand: someFunc3,
                },
                articles: {
                    click: someFunc4,
           },
            },
            show: someFunc5,
        },
        header: {
            logo: someFunc6,
            user: {
                login: someFunc7,
                logout: someFunc8,
            },
        },
        show: someFunc9,
    },
};

```
---

## ЗАДАЧА
Напишите функцию, которая обрабатывает текущую модель и возвращает новый объект типа «композитный ключ/новая функция», где новая функция — это функция, которая возвращает результат изначальной функции с переданным композитным ключом в качестве параметра. Композитный ключ — это ключ, который представляет собой перечисление вложенных ключей модели через точку. К примеру:

```js

page.content.form.submit
или

page.content.infoBlock.more.click
и так далее.

Соответственно, ответ будет выглядеть как объект, например:

{
   page.content.form.submit: someNewFunction1,
   page.content.infoBlock.more.click: someNewFunction2,
   
   // и так далее
}

```
---

## ШАБЛОН КОДА
Используйте данный шаблон для написания кода и отправки его на сервер для проверки.

```js
function solution(root) {
    // Ваш код здесь
}

module.exports = solution;

```
---
# E. Доступность спутников

Вы работаете оператором в центре управления космическими аппаратами. Вам необходимо определить, какие из спутников в данный момент поддерживают связь. Каждый спутник проверяется специальной системой мониторинга, которая работает с переменной задержкой. Задача: написать функцию, которая принимает список спутников и возвращает названия только тех, которые в данный момент доступны для связи. Проверки должны выполняться максимально эффективно по времени. Спутник считается недоступным, если не отвечает или отвечает дольше 3000 мс.

Напишите функцию getAvailableSatellites, которая будет возвращать массив станций, которые доступны. На вход функции подаётся массив объектов, состоящих из поля name и из поля check - функция, которая определяет, доступен ли этот спутник.

## Формат ввода
```js
[
  {
    name: "Первый",
    check: () => { Promise } 
  },
  {
    name: "Второй", 
    check: () => { Promise } 
  }
]

// Формат вывода: ["Второй"]
```
---

## Шаблон решения

```js

function getAvailableSatellites(satellites, timeoutMs) {
    // Ваш код
}

module.exports = getAvailableSatellites;
```